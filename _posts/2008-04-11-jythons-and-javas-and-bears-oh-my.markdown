--- 

title: Jythons and Javas and bears, oh my!
wordpress_id: 122
wordpress_url: http://lackoftalent.org/michael/blog/?p=122
date: 2008-04-11 21:41:52 -04:00
---
It's hard to believe but I've been at the <a href="http://lackoftalent.org/michael/blog/2007/09/27/october/" target="_blank">new job</a> for six months already, a full half-year come the 29th.  Some days it seems like I've been here forever; others like I'm still a rank newb.   I haven't written terribly much about what I've been up to (but I assure you I've been busy).  Let me rectify that.
<h2><strong>The Transfer Problem</strong></h2>
Two of the projects I've been working on relate to a fairly general problem that we like to call "transfer," which revolves around, well, transferring files to and fro.  Sounds simple.  <em>Is</em> simple.  That is, until you start thinking about preservation and accounting for a highly heterogeneous network with idiosyncratic nodes, esoteric storage software, and differential firewall rules.  And that's where it gets interesting (and problematic). <!--more-->The transferring itself, or copying of files from one location to another which we call "transport," is the easiest part.  We like to use common tools in our environment.  It makes life easy.  And so good ol' <a href="http://en.wikipedia.org/wiki/Secure_copy" target="_blank">scp</a> seems like an obvious choice to handle the job.

Since preservation is a core aspect of our "repository," a term which I use loosely, we must build certain other functionalities into the transfer process: validation, verification, inventory, backup, ingest, and so forth.  Every time a file is copied to a non-transient location, we verify the file against a (<a href="http://www.faqs.org/rfcs/rfc3174.html" target="_blank">SHA1</a>) checksum and record an event for auditing purposes.
<h2><strong>Repository Workflows</strong></h2>
Some steps in the transfer process are routine and best handled by machines. Thus we automate them with scripts and code.  Others require human intervention.  This introduces another key aspect of our repository needs: workflows.  No two projects will have the same workflow and yet all will have some steps in common.  We're using JBoss's <a href="http://www.jboss.org/jbossjbpm/" target="_blank">jBPM</a> library for workflow management and it is more than capable of handling our workflow needs.  It allows us to model complex and varied flows in a robust and not <em>ad hoc</em> way; it does seem preferable to me to model our workflows via jBPM's graphical editor (serialized to <a href="http://docs.jboss.com/jbpm/v3/userguide/jpdl.html" target="_blank">JPDL</a> XML) rather than copying around blocks of code and otherwise modeling the workflow procedurally in business logic.

One of my coworkers (<a href="http://www.dlib.org/dlib/july07/littman/07littman.html" target="_blank">the author of this</a>) designed a complete workflow system in jBPM last summer and I've taken on implementing, tweaking, and testing this system, which has required bootstrapping my sorry-arse Java skills and learning jBPM.  Though I find it difficult to think in Java patterns and generally find it a burdensome environment, I'm quite impressed by jBPM.  I've been working on various updates of and unit test coverage for the workflow system, which has been a crash course in a number of Java technologies and a perfect first task at LC, as it gets me into the guts of things.  The Java stack we use for our workflow is highly abstracted and componentized, which is conveniently modular... but it's also Java: fairly heavy and arguably not as agile as dynamic languages such as Python.
<h2><strong>Two Great Tastes?</strong></h2>
So recently we've begun to think about implementing some transfer and workflow components in <a href="http://www.jython.org/" target="_blank">Jython</a> (Python written in Java).  Why?  The value of Jython is as follows:
<ol>
	<li><strong>Ease of deployment</strong> - Deploying jar files to existing JVMs in production environments (which we do not control) is a simple task, or at least simpler than some other options.</li>
	<li><strong>Interoperability</strong> - Our stack is primarily Java-based and so interoperating with existing Java components means not having to rewrite functionality in other languages.  Jython allows Python to talk to Java and vice versa.</li>
	<li><strong>Familiarity</strong> - It's Python, and we like Python.  It's the closest my team has to a <em>lingua franca</em> and so it increases the chances of sharing code, maintaining code, and so forth.</li>
</ol>
It does not come without its drawbacks:
<ol>
	<li><strong>Currency</strong> - The Jython project went moribund for a few years or so and the latest stable version is now 2.2.1.  Compare that to the latest version of Python: <a href="http://www.python.org/download/releases/2.5.2/" target="_blank">2.5.2</a>.  I don't begrudge the Jython developers, though.  I'm glad some folks picked the project up, dusted it off, and breathed new life into it.   I am also glad that they're skipping 2.3 and 2.4 releases and plowing right into a 2.5 release.  Because of this currency issue, some Python libraries won't work with the latest Jython and that means you're stuck looking for outdated, potentially vulnerable Python libraries, or hooking into Java libraries for the same functionality (which inevitably means more lines of code).  I'm no lines of code fetishist but it does militate against the goal of agility somewhat.One does have the option of living on the edge and trying out the 2.5 branch, but that seems out of step with an infrastructure that is supposed to preserve terabytes upon terabytes of our nation's, and the world's, intellectual property.  It's a responsibility I do not take lightly, as much as I'd like to be on the bleeding edge.</li>
	<li><strong>Interoperability difficulties - </strong>Talking to Java from Jython is a snap: just <code>import java</code> at the top of your script, and, assuming your classpath is copacetic, <em>voila:</em> you have access to Java libraries in your Python code!  Talking to your Jython modules from Java code is, well, a little more complicated. Read on.</li>
</ol>
Despite the caveats it does seem a sane, reasonable, and potentially productive path to go down. Right?  I am specifically looking to implement two workflow components in Jython: one for transport (wrapping Ant's<a href="http://www.jcraft.com/jsch/" target="_blank"> JSch</a> library, which provides a slick scp API) and the other for automation of <a href="http://www.opensolaris.org/os/community/zfs/" target="_blank">ZFS</a> filesystem/volume creation on the staging server.  Nothing arcane, nothing tricky, nothing fancy.  So it must be easy!  Right? ...
<h2><strong>Lessons Learned?</strong></h2>
I'm beginning to wonder about the feasibility of using Jython to make bits of our Java stack more agile. Specifically, there are three ways to get at Jython code from Java:
<ol>
	<li>Compile to bytecode/jar via the Jython compiler (jythonc) and reference your Jython objects and methods as though they were <a href="http://en.wikipedia.org/wiki/POJO" target="_blank">POJOs</a></li>
	<li>Embed a Jython interpreter</li>
	<li>Instantiate a (<a href="http://jcp.org/en/jsr/detail?id=223" target="_blank">JSR-223</a>) script engine</li>
</ol>
Option 1 is nice because you get object- and method-level interop.  However, <a href="http://www.jython.org/Project/jythonc.html" target="_blank">jythonc</a> is unsupported and will disappear.  This does not seem sustainable though I might be able to limp along a while.  And there are <a href="http://sourceforge.net/mailarchive/message.php?msg_name=96c4692d0802280853r70e6b74fg71aed3cdd7701cbf%40mail.gmail.com" target="_blank">signs of hope</a>:
<blockquote>Though jythonc is going away, all of the capabilities it provides will be present in 2.5 in other forms.  We're adding functionality to expose Python classes as Java classes using decorators to replace the docstring class creation that jythonc provided, and we're adding static compilation of proxy classes so regular jython can run in applets and other environments with restrictive classloaders.  We're definitely doing something about jythonc.</blockquote>
That doesn't help much <em>now</em>, of course, but just because jythonc goes away does not mean my jars will stop working.

The suggested methods for option 2 [<a href="http://wiki.python.org/jython/JythonMonthly/Articles/October2006/3" target="_blank">1</a>, <a href="http://wiki.python.org/jython/JythonMonthly/Articles/September2006/1" target="_blank">2</a>] seem to be more trouble than they're worth.  If the goal is more agile development for certain components, the reliance upon multiple, separate Java classes -- an interface class and an object factory, in the examples listed -- to get a ten-line Jython script working, this seems suboptimal, both inefficient and not straightforwardly maintainable; it seems, to me and my Java-dumb ways, rather baroque.

Option 3 [<a href="http://wiki.python.org/jython/JythonMonthly/Articles/October2006/1" target="_blank">1</a>, <a href="http://www.jython.org/Project/userguide.html#using-jsr-223" target="_blank">2</a>] is more appealing than option 2 as it does not rely upon these other classes specifically for Jython code.  But the number of lines of Java code that must be wrapped around the Jython to get it working looks like overkill for the drop-dead simple scripts I'm writing -- it might be easier, for instance, to just write the darn things in Java and be done with it.  (Did I just say that?)
<h2><strong>Conclusions</strong></h2>
Options 2 and 3 are similar as both involve embedding Jython code, or referencing files with Jython code, and interpreting the code within Java.  Generally, I worry that either option would obviate the benefit of agile Jython scripting because you wind up wrapping the code in so much Java.  I offer two disclaimers to counter my objections:
<ol>
	<li>Cleverer Java coders than myself could, I am almost certain, find ways to build abstractions (or abstractions of abstractions) to eliminate the "lines of code" and "many separate classes per Jython script" issues</li>
	<li>The value of Jython in our Java environment increases proportionately with the complexity of the component -- given the overhead, a short Java class seems easier and more straightforward to implement than a short embedded Jython script.  On the other hand, there's value in embedding a Jython script that'd be an order of magnitude simpler than its Java analog.</li>
</ol>
At least, that's the state of my head right now re: getting Jython and Java to play nice.  If I make any breakthroughs or give up entirely, I'll post follow-ups.

I am but a Java philistine and a Jython neophyte, so I remain humbly open-minded.  I would greatly appreciate comments, questions, corrections, smackdowns, sagacious advice, and so on.
